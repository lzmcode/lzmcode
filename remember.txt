Pick定理和叉积求多边形的面积。
Pick定理：一个计算点阵中顶点在格点上的多边形面积公式：S=a+b/2-1，其中a表示多边形内部的点数，b表示多边形边界上的点数，s表示多边形的面积。

多边形面积：
1) △ABC的面积为向量AB与向量AC的叉乘的一半。
2)对于一个多边形，选定一个顶点P1，与其他顶点连线，可将多边形分为若干个三角形。
3)多边形面积为 abs(Sum{CrossMul(A,B,P1)|A,B为相邻的两个顶点}) (先求和再取abs，否则对于凹多边形会出错）

求在边上的顶点数：
对于Pa(x1,y1),Pb(x2,y2)所连成的选段，经过的格点的个数为Gcd(abs(x1-x2),abs(y1-y2))+1.

字典树

动态规划算法三要素（摘自黑书，总结的很好，很有概括性
①所有不同的子问题组成的表
②解决问题的依赖关系可以看成是一个图
③填充子问题的顺序（即对②的图进行拓扑排序，填充的过程称为状态转移

则如果子问题的数目为O(nt)，每个子问题需要用到O(ne)个子问题的结果，那么我们称它为tD/eD的问题，于是可以总结出四类常用的动态规划方程：
      （下面会把opt作为取最优值的函数（一般取min或max）, w(j, i)为一个实函数，其它变量都可以在常数时间计算出来）。)
       1、1D/1D
             d[i] = opt{ d[j] + w(j, i) | 0 <= i < j } (1 <= i <= n)
             【例题4】和【例题5】都是这类方程。
       2、2D/0D
             d[i][j] = opt{ d[i-1][j] + xi, d[i][j-1] + yj, d[i-1][j-1] + zij }     (1<= i, j <= n)
             【例题7】是这类方程的变形，最典型的见最长公共子序列问题。
       3、2D/1D
              d[i][j] = w(i, j) + opt{ d[i][k-1] + d[k][j] }, (1 <= i < j <= n)
               区间模型常用方程。
               另外一种常用的2D/1D的方程为：
              d[i][j] = opt{ d[i-1][k] + w(i, j, k) | k < j }    (1<= i <= n, 1 <= j <= m)
       4、2D/2D
              d[i][j] = opt{ d[i'][j'] + w(i', j', i, j) |  0 <= i' < i, 0 <= j' < j}
             常见于二维的迷宫问题，由于复杂度比较大，所以一般配合数据结构优化，如线段树、树状数组等。
       对于一个tD/eD 的动态规划问题，在不经过任何优化的情况下，可以粗略得到一个时间复杂度是O(nt+e)，空间复杂度是O(nt)的算法，大多数情况下空间复杂度是很容易优化的，难点在于时间复杂度，下一章我们将详细讲解各种情况下的动态规划优化算法。

标准模板
#include<cstdio>
#include<queue>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<iostream>

#define LL long long
#define clr(a, b) memset(a, b, sizeof(a)
#define height(p) ( (p==NULL) ? -1 : (((Node *)(p))->height) )
#define max(a, b) ( (a) > (b) ? (a) : (b) )
const int MAXN = 100050;
const int HALF = 0x3f3f3f3f;
const int INF = (~(0x1<<31));
using namespace std;

